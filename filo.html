<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'amateur d'électronique</title>
    <link rel="stylesheet" href="site_web_css.css">
</head>
<body>

<header>
    <h1>L'amateur d'électronique</h1>
    <nav>
        <ul>
            <li><a href="site_web_login.html">Présentation</a></li>
            <li><a href="projets.html">Projets</a></li>
            <li><a href="https://www.youtube.com/@L_amateur_d_electronique" target="_blank">YouTube</a></li>
        </ul>
    </nav>
</header>

<section id="projets" class="section">
    <h2>Filo : le robot filoguidé</h2>

    <h3>
        Dans cette rubrique, nous vous parlerons du projet FILO. Le but est de créer un petit robot mobile capable de se déplacer en totale autonomie en suivant une piste tracée par un conducteur électrique.
    </h3>
    <img src="filo_guide.jpg" alt="Robot suiveur de ligne" class="responsive-img">

    <p>
        FILO utilise un asservissement proportionnel pour suivre le fil. Les bobines à l’avant comparent le signal capté : si le robot s’écarte, le système ajuste automatiquement la vitesse des moteurs pour le recentrer.
    </p>
    <img src="filo.jpg" alt="Robot suiveur de ligne" class="responsive-img">

    <h2>Le filtrage du signal</h2>
    <p>
        Pour permettre au microcontrôleur de lire correctement le signal, nous utilisons un <strong>filtre passe-bas</strong> qui extrait la valeur moyenne du signal.
    </p>
    <img src="montage2.jpg" alt="Filtrage du signal" class="responsive-img">

    <h3>1. Définir le temps de réponse souhaité</h3>
    <p>
        La relation est <code>t<sub>rép</sub> = 2,2 / f<sub>c</sub></code>. Nous avons choisi 1 ms pour un système réactif.
    </p>

    <h3>2. Calculer la fréquence de coupure</h3>
    <p><code>f<sub>c</sub> = 0,35 / 1 ms = 350 Hz</code></p>

    <h3>3. Dimensionner le filtre RC</h3>
    <p><code>RC = 1 / (2π × f<sub>c</sub>)</code></p>

    <h3>4. Câbler le filtre</h3>
    <p>
        Le filtre est monté avec une résistance en série et un condensateur à la masse. Le signal est alors lissé.
    </p>

    <h3>Signal redressé</h3>
    <img src="signal_redresse1.jpg" alt="Signal redressé" class="responsive-img">
    <p>On obtient la valeur moyenne du signal, soit (Umax/π).</p>

    <h2>Montage électronique du module capteur</h2>
    <img src="montage1_fini.jpg" alt="Montage électronique" class="responsive-img">
    <p>
        Pour étendre la détection, nous dupliquons le montage et ajoutons un amplificateur non inverseur fournissant 3,3 V.
    </p>

    <h2>Assemblage du robot</h2>
    <p>
        Assemblage des roues et composants du robot FiLo :
    </p>
    <ul>
        <li>Carte driver DRI0044-A</li>
        <li>Microcontrôleur MSP430G2553</li>
        <li>Moteurs DC-DC</li>
    </ul>
    <img src="schema_filo_brut.jpg" alt="Schéma du robot" class="responsive-img">
    <img src="carte_moteur.jpg" alt="Carte moteur" class="responsive-img">

    <h3>Alimentation</h3>
    <p>
        La carte driver et le microcontrôleur fonctionnent sous 3,3 V, les moteurs sous 5 V. Un convertisseur DC-DC LE33ABD permet de passer de 5,2 V à 3,3 V.
    </p>
    <img src="transistor_mos.jpg" alt="Transistor MOS" class="responsive-img">

    <h2>L'asservissement du robot</h2>
    <p>Les bobines détectent si le robot est centré ou dévié. Chaque moteur est contrôlé via PWM.</p>
    <img src="pid.jpg" alt="Asservissement PID" class="responsive-img">

    <h3>Microcontrôleur</h3>
    <p>Le MSP430G2553 traite les signaux des capteurs et commande les moteurs.</p>
    <img src="micro_msp.jpg" alt="MSP430G2553" class="responsive-img">

    <h3>Contrôle des moteurs</h3>
    <p>La vitesse des moteurs est modifiée par un signal PWM.</p>
    <img src="pwm.jpg" alt="PWM pour moteurs" class="responsive-img">

    <h2>Programmation du robot filoguidé</h2>
    <h3>Étape 1 : Récupération des données</h3>
    <pre><code>int valeurBobine1 = analogRead(A0);
int valeurBobine2 = analogRead(A4);</code></pre>

    <h3>Étape 2 : Programmation de la carte Dual Motor Driver TB6612</h3>
    <pre><code>digitalWrite(pinSensMoteur1, 1);
digitalWrite(pinSensMoteur2, 0);
analogWrite(PWM1, vitesse);
analogWrite(PWM2, vitesse);</code></pre>

    <h2>Vidéo du résultat</h2>
    <div class="project-card">
        <a href="https://www.youtube.com/shorts/70cZsBATUMQ" target="_blank">
            <img src="https://i.ytimg.com/vi/70cZsBATUMQ/oardefault.jpg?sqp=-oaymwEoCJUDENAFSFqQAgHyq4qpAxcIARUAAIhC2AEB4gEKCBgQAhgGOAFAAQ==&rs=AOn4CLBpO7WmVY22GI3imF3Ep55LEhwo1A" alt="Robot filoguidé" class="responsive-img">
            <h3>Robot filoguidé</h3>
            <p>Voir la vidéo ➜</p>
        </a>
    </div>
</section>

<footer>
    <p>© 2025 - L'amateur d'électronique</p>
</footer>

</body>
</html>
